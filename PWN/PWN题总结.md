# PWN总结

[一步一步学ROP之linux_x64篇](https://segmentfault.com/a/1190000007406442)

## 栈溢出



### 栈溢出前提

发生栈溢出有两个基本前提：

- 程序必须向栈上写入数据。
- 写入的数据大小没有被良好地控制。



### 栈溢出基本步骤

#### 寻找危险函数

通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出位置在哪里。常见危险函数如下：

- 输入
  - gets，直接读取一行，忽略'\x00'
  - scanf
  - vscanf
- 输出
  - sprintf
- 字符串
  - strcpy，字符串复制，遇到'\x00'停止
  - strcat，字符串拼接
  - bcopy

#### 确定填充长度

这一部分主要是计算**我们所要操作的地址与我们所要覆盖的地址的距离**。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式

- 相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得
- 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型
- 直接地址索引，就相当于直接给定了地址

一般来说，我们会有如下的覆盖需求

- **覆盖函数返回地址**，这时候就是直接看 EBP 即可。
- **覆盖栈上某个变量的内容**，这时候就需要更加精细的计算了。
- **覆盖 bss 段某个变量的内容**。
- 根据现实执行情况，覆盖特定的变量或地址的内容。

之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来**直接或者间接地控制程序执行流程**。



### ROP

#### ROP攻击条件

- 程序存在溢出，并且可以控制返回地址。
- 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。

#### 初级ROP一般思路

**前提是在无Canary的情况下：**

1. 程序源码自带系统命令函数：直接覆盖返回地址即可
2. 程序源码无目的函数，但可以找到system函数的plt的绝对地址；使用ret2text
3. 没有NX保护，找不到system函数，利用输入函数，将shellcode写入到程序中：ret2shellcode
4. 有NX保护，利用ROPGadget配合int 0x80调用execve：ret2Syscall
5. 有NX保护，利用Libc获取system函数的相对位置：ret2Libc



#### 中级ROP













### 常用指令

```
info function  #gdb 查看程序的函数
```

![](https://ms-study.oss-cn-chengdu.aliyuncs.com/Binary_study/RE/Snipaste_2021-06-24_20-36-10.png)

