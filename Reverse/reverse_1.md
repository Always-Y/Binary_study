## Reverse_1

---

BUUCTF刷题----RE第二题

---

### 运行程序观察程序特征

![图1](D:\Binary_Study\reverse_1\1.PNG)

 由上图可知，该程序直接输入Flag,	回车之后界面一闪而过，无结果输出显示：**多半是由于程序没有断点 一闪而过 所以看不到输出**

 同样的可以推断	该Flag以字符串固定存储在数据；然后与输入的字符串进行对比；



### 使用查壳工具进行查壳

 X64 VC开发 ，无壳，水平有限，了解不多，所以没有深入,也就不展开了 



### 分析步骤

1.将程序拖入IDA 分析；结果如下图

![图2](D:\Binary_Study\reverse_1\2.PNG)

由上图可知，将Reverse_1拖入IDA后，并没有什么有用信息，程序的流程和入口点，都不是很清楚；

2.为解决这个问题，就是用到前面观察到的特征,即出现了“Input the Flag”的字符串，根据该字符串的交叉引用来定位

Shift+F12 可得到以下窗口

![图三](D:\Binary_Study\reverse_1\3.PNG)



双击该字符串进入所在位置 可得到如下图所示

![图4](D:\Binary_Study\reverse_1\4.png)

由上图可知在该字符串后面标明的两个函数，即为引用该字符串的函数，使用鼠标双击即可进入该函数所在的位置

![图5](D:\Binary_Study\reverse_1\5.PNG)



F5 即可得到该程序的主要流程函数

![图6](D:\Binary_Study\reverse_1\6.PNG)

**由上图可知，27-30 输入字符串存储在str1中然后和字符串str2(原本已经存在程序中)，进行对比，若是相等，字符串“this is the right flag！”的字符串，说明输入的字符串即为Flag，由此可知，在30行的 if语句下断点，此时的str2即为flag**

下断点后，按照要求输入，程序成功断点如下图所示

![图7](D:\Binary_Study\reverse_1\7.PNG)

**从上图中已经可以看到此时Str2的值   即为flag**



### 进一步分析

由上面图中的主要流程代码，鼠标双击Str2 即可跳入str2所在位置，显示该值 见下图

![图8](D:\Binary_Study\reverse_1\8.PNG)

由上图可知 Str2 为 与上图的程序调试中的str2不一样，而且该值不是flag，由此可知，明显str2字符串在程序加载后自动进行了修改，将原本明文存储的字符串加以改变，仔细查看上图中的主要代码

就能发现 18行-- 26行 代码 将字符串中的 字母‘o’ 替换成了 ‘0’得到flag



